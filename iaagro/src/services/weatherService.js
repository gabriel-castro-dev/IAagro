/**
 * Servi√ßo para dados meteorol√≥gicos
 * Utiliza a API do OpenWeatherMap
 */

// Configura√ß√µes da API usando vari√°veis de ambiente
const API_KEY = process.env.REACT_APP_WEATHER_API_KEY || 'cc11141a4c6ee7ff6a52fb92d7b16c29';
const BASE_URL = process.env.REACT_APP_WEATHER_BASE_URL || 'https://api.openweathermap.org/data/2.5';

// Verifica√ß√£o de API Key
if (!process.env.REACT_APP_WEATHER_API_KEY) {
    console.warn('‚ö†Ô∏è Weather API Key n√£o encontrada nas vari√°veis de ambiente. Usando fallback.');
}

/**
 * Limpar nome da cidade (remove pa√≠s e formata√ß√µes extras)
 */
const cleanCityName = (cityName) => {
    if (!cityName) return '';
    
    // Remove ", BR" ou ", Brasil" do final
    let cleaned = cityName.replace(/,\s*(BR|Brasil)$/i, '').trim();
    
    // Remove acentos para melhor compatibilidade
    cleaned = cleaned.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    
    return cleaned;
};

/**
 * Busca dados do clima por nome da cidade
 * @param {string} cityName - Nome da cidade
 * @param {string} countryCode - C√≥digo do pa√≠s (opcional, padr√£o: BR)
 * @returns {Promise<Object>} - Dados do clima
 */
export const getWeatherByCity = async (cityName, countryCode = 'BR') => {
    try {
        if (!cityName) {
            throw new Error('Nome da cidade √© obrigat√≥rio');
        }

        // Limpar o nome da cidade
        const cleanedCity = cleanCityName(cityName);
        
        console.log('üå§Ô∏è Buscando clima para:', cleanedCity);

        // Montar query: "cidade,c√≥digo_pa√≠s"
        const query = `${cleanedCity},${countryCode}`;
        
        const apiUrl = `${BASE_URL}/weather?q=${encodeURIComponent(query)}&appid=${API_KEY}&units=metric&lang=pt_br`;
        
        console.log('üì° URL da API:', apiUrl.replace(API_KEY, 'API_KEY_HIDDEN'));
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        console.log('üìä Resposta da API:', data);

        if (data.cod !== 200) {
            console.error('‚ùå Erro da API:', data.message);
            throw new Error(data.message || 'Cidade n√£o encontrada');
        }

        return {
            success: true,
            data: {
                city: data.name,
                country: data.sys.country,
                temp: Math.round(data.main.temp),
                tempMax: Math.round(data.main.temp_max),
                tempMin: Math.round(data.main.temp_min),
                description: data.weather[0].description,
                tempIcon: data.weather[0].icon,
                windSpeed: data.wind.speed,
                humidity: data.main.humidity,
                pressure: data.main.pressure,
                visibility: data.visibility / 1000, // em km
                sunrise: new Date(data.sys.sunrise * 1000),
                sunset: new Date(data.sys.sunset * 1000),
                coordinates: {
                    lat: data.coord.lat,
                    lon: data.coord.lon
                }
            }
        };
    } catch (error) {
        console.error('‚ùå Erro ao buscar dados do clima:', error);
        return {
            success: false,
            error: error.message,
            data: null
        };
    }
};

/**
 * Busca dados do clima por CEP (usando ViaCEP + OpenWeather)
 * @param {string} cep - CEP da localidade
 * @returns {Promise<Object>} - Dados do clima
 */
export const getWeatherByCEP = async (cep) => {
    try {
        if (!cep) {
            throw new Error('CEP √© obrigat√≥rio');
        }

        // Limpar CEP
        const cleanedCEP = cep.replace(/\D/g, '');
        
        console.log('üîç Buscando localiza√ß√£o por CEP:', cleanedCEP);

        // Buscar endere√ßo pelo CEP
        const cepResponse = await fetch(`https://viacep.com.br/ws/${cleanedCEP}/json/`);
        const cepData = await cepResponse.json();

        if (cepData.erro) {
            throw new Error('CEP n√£o encontrado');
        }

        const cidade = cepData.localidade;
        const estado = cepData.uf;

        console.log('üìç Localiza√ß√£o encontrada:', cidade, estado);

        // Buscar clima pela cidade
        return await getWeatherByCity(cidade, 'BR');

    } catch (error) {
        console.error('‚ùå Erro ao buscar clima por CEP:', error);
        return {
            success: false,
            error: error.message,
            data: null
        };
    }
};

/**
 * Busca dados do clima por coordenadas
 * @param {number} lat - Latitude
 * @param {number} lon - Longitude
 * @returns {Promise<Object>} - Dados do clima
 */
export const getWeatherByCoordinates = async (lat, lon) => {
    try {
        if (!lat || !lon) {
            throw new Error('Coordenadas s√£o obrigat√≥rias');
        }

        console.log('üåç Buscando clima por coordenadas:', { lat, lon });

        const apiUrl = `${BASE_URL}/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric&lang=pt_br`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.cod !== 200) {
            throw new Error(data.message || 'Localiza√ß√£o n√£o encontrada');
        }

        return {
            success: true,
            data: {
                city: data.name,
                country: data.sys.country,
                temp: Math.round(data.main.temp),
                tempMax: Math.round(data.main.temp_max),
                tempMin: Math.round(data.main.temp_min),
                description: data.weather[0].description,
                tempIcon: data.weather[0].icon,
                windSpeed: data.wind.speed,
                humidity: data.main.humidity,
                pressure: data.main.pressure,
                visibility: data.visibility / 1000,
                sunrise: new Date(data.sys.sunrise * 1000),
                sunset: new Date(data.sys.sunset * 1000),
                coordinates: {
                    lat: data.coord.lat,
                    lon: data.coord.lon
                }
            }
        };
    } catch (error) {
        console.error('‚ùå Erro ao buscar clima por coordenadas:', error);
        return {
            success: false,
            error: error.message,
            data: null
        };
    }
};

/**
 * Busca previs√£o de 5 dias
 * @param {string} cityName - Nome da cidade
 * @param {string} countryCode - C√≥digo do pa√≠s (opcional)
 * @returns {Promise<Object>} - Previs√£o do tempo
 */
export const getWeatherForecast = async (cityName, countryCode = 'BR') => {
    try {
        if (!cityName) {
            throw new Error('Nome da cidade √© obrigat√≥rio');
        }

        const cleanedCity = cleanCityName(cityName);
        const query = `${cleanedCity},${countryCode}`;

        const apiUrl = `${BASE_URL}/forecast?q=${encodeURIComponent(query)}&appid=${API_KEY}&units=metric&lang=pt_br`;
        
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.cod !== "200") {
            throw new Error(data.message || 'Cidade n√£o encontrada');
        }

        return {
            success: true,
            data: {
                city: data.city.name,
                country: data.city.country,
                forecast: data.list.map(item => ({
                    date: new Date(item.dt * 1000),
                    temp: Math.round(item.main.temp),
                    tempMax: Math.round(item.main.temp_max),
                    tempMin: Math.round(item.main.temp_min),
                    description: item.weather[0].description,
                    icon: item.weather[0].icon,
                    humidity: item.main.humidity,
                    windSpeed: item.wind.speed
                }))
            }
        };
    } catch (error) {
        console.error('‚ùå Erro ao buscar previs√£o do tempo:', error);
        return {
            success: false,
            error: error.message,
            data: null
        };
    }
};

/**
 * Obt√©m localiza√ß√£o atual do usu√°rio
 * @returns {Promise<Object>} - Coordenadas
 */
export const getCurrentLocation = () => {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error('Geolocaliza√ß√£o n√£o suportada'));
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                resolve({
                    lat: position.coords.latitude,
                    lon: position.coords.longitude
                });
            },
            (error) => {
                reject(new Error('Erro ao obter localiza√ß√£o: ' + error.message));
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutos
            }
        );
    });
};

/**
 * Formata temperatura para exibi√ß√£o
 * @param {number} temp - Temperatura
 * @returns {string} - Temperatura formatada
 */
export const formatTemperature = (temp) => {
    return `${Math.round(temp)}¬∞C`;
};

/**
 * Obt√©m √≠cone do clima da OpenWeather
 * @param {string} iconCode - C√≥digo do √≠cone
 * @returns {string} - URL do √≠cone
 */
export const getWeatherIcon = (iconCode) => {
    return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
};

/**
 * Mapear c√≥digos de clima para emojis
 */
export const getWeatherEmoji = (iconCode) => {
    const emojiMap = {
        '01d': '‚òÄÔ∏è', // c√©u limpo (dia)
        '01n': 'üåô', // c√©u limpo (noite)
        '02d': '‚õÖ', // poucas nuvens (dia)
        '02n': '‚òÅÔ∏è', // poucas nuvens (noite)
        '03d': '‚òÅÔ∏è', // nuvens dispersas
        '03n': '‚òÅÔ∏è',
        '04d': '‚òÅÔ∏è', // nuvens quebradas
        '04n': '‚òÅÔ∏è',
        '09d': 'üåßÔ∏è', // chuva
        '09n': 'üåßÔ∏è',
        '10d': 'üå¶Ô∏è', // chuva (dia)
        '10n': 'üåßÔ∏è', // chuva (noite)
        '11d': '‚õàÔ∏è', // tempestade
        '11n': '‚õàÔ∏è',
        '13d': '‚ùÑÔ∏è', // neve
        '13n': '‚ùÑÔ∏è',
        '50d': 'üå´Ô∏è', // neblina
        '50n': 'üå´Ô∏è'
    };
    
    return emojiMap[iconCode] || 'üå§Ô∏è';
};